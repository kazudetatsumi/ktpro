#!/usr/bin/env python
# This script gathers the Cn.hdf5 files generated by optbinwidth4D_wholefort.py  for several INS data sets with different measerement times
# and summarizes the statistics, plot the 1/m - 1/delta (extrapolation)  and 1/n - 1/delta (optimzation for the data).
# 2020/02/15 Kazuyoshi TATSUMI
import numpy as np
import matplotlib.pyplot as plt
import h5py


def get_optid(m, n, Cn, kave, delta):
    ex = np.zeros((delta.shape[0], delta.shape[1], delta.shape[2], delta.shape[3]))
    ex[1:, 1:, 1:, 1:] = (1/m - 1/n) * kave[1:, 1:, 1:, 1:] / (delta[1:, 1:, 1:, 1:]**2*n)
    ex[0, :, :, :] = 0.0
    ex[:, 0, :, :] = 0.0
    ex[:, :, 0, :] = 0.0
    ex[:, :, :, 0] = 0.0
    Cm = ex + Cn
    optid = np.unravel_index(np.argmin(Cm, axis=None), Cm.shape)
    return optid


def unite_hdf5(num_hdfs, head):
    for i in range(0, num_hdfs):
        outfile = head + str(i+1) + "h/Cn.hdf5"
        f = h5py.File(outfile, 'r')
        if i == 0:
            tCn = np.zeros((f["Cn"].shape[0], f["Cn"].shape[1], f["Cn"].shape[2], f["Cn"].shape[3], num_hdfs))
            tdelta = np.zeros((f["delta"].shape[0], f["delta"].shape[1], f["delta"].shape[2], f["delta"].shape[3], num_hdfs))
            tkave = np.zeros((f["kave"].shape[0], f["kave"].shape[1], f["kave"].shape[2], f["kave"].shape[3], num_hdfs))
        tCn[:, :, :, :, i] = f["Cn"]
        tdelta[:, :, :, :, i] = f["delta"]
        tkave[:, :, :, :, i] = f["kave"]
        datafile = head + str(i+1) + "h/eliminated_data.hdf5"
        g = h5py.File(datafile, 'r')
        if i == 0:
            tTotInt = np.zeros((num_hdfs))
        tTotInt[i] = np.sum(g["data4"])
    outfile = head + "Cn_all.hdf5"
    with h5py.File(outfile, 'w') as hf:
        hf.create_dataset('tCn', data=tCn)
        hf.create_dataset('tdelta', data=tdelta)
        hf.create_dataset('tkave', data=tkave)
        hf.create_dataset('tTotInt', data=tTotInt)


def get_stat_via_unitehdf5(head):
    outfile = head + "Cn_all.hdf5"
    f = h5py.File(outfile, 'r')
    tCn = f["tCn"]
    tdelta = f["tdelta"]
    tkave = f["tkave"]
    tTotInt = f["tTotInt"]
    return tCn, tdelta, tkave, tTotInt


def runex():
    #head = "/home/kazu/desktop/200204/fine/hourbyhour/"
    head = "./"
    num_hdf = 10
    unite_hdf5(num_hdf, head)
    tCn, tdelta, tkave, tTotInt = get_stat_via_unitehdf5(head)
    outfile = "result.txt_vec"
    result = []

    for hid in range(1, num_hdf + 1):
        print("Extraporation with n = ", tTotInt[hid - 1])
        l_result = []
        Cn = tCn[:, :, :, :, hid - 1]
        kave = tkave[:, :, :, :, hid - 1]
        delta = tdelta[:, :, :, :, hid - 1]
        n = tTotInt[hid - 1]
        Cn = Cn / (n**2)   # This is according to the Cn in NeCo(2007)
        for m in tTotInt:  # Here we extrapolate the optimzation from the total intensity of the data, n, toward m taken as each of total intennsities acquired with different measurement times.
            optid = get_optid(m, n, Cn, kave, delta)
            l_result.append([optid[0]+1, optid[1]+1, optid[2]+1, optid[3]+1, m]) # Because numpy index starts from 0, here we add 1 for treating the actual amounts of the width.
            if m == tTotInt[-1]:
                max_optid = optid
        for mn_ratio in np.arange(1.1, 20.1, 0.1):
            m = mn_ratio * tTotInt[hid - 1]
            optid = get_optid(m, n, Cn, kave, delta)
            if 1/(np.prod(np.array(optid)+1)*1.0) > 1/(np.prod(np.array(max_optid)+1)*1.0):
                max_optid = optid
                l_result.append([optid[0]+1, optid[1]+1, optid[2]+1, optid[3]+1, m]) # Because numpy index starts from 0, here we add 1 for treating the actual amounts of the width.
        result.append(l_result)
    with open(outfile, mode='w') as f:
        f.write("optimization results for 17714 data: n, optid_x, optid_y, optid_z, optid_w, 1/n, 1/(optidnx_x*optid_y*optid_z*optid_w) \n")
        for hid in range(0, num_hdf):
            f.write("%e %d %d %d %d %e %e\n" %
             (
              result[hid][hid][4], result[hid][hid][0], result[hid][hid][1], result[hid][hid][2], result[hid][hid][3], 1/(result[hid][hid][4]*1.0),
              1/(np.prod(np.array(result[hid][hid][0:4]))*1.0)
             )
            )
        f.write("extraporation results for 17714 data: m, optid_x, optid_y, optid_z, optid_w, 1/m, 1/(optidnx_x*optid_y*optid_z*optid_w) \n")
        for hid in range(0, num_hdf):
            f.write("For n = %e \n" % tTotInt[hid])
            #for Indx_of_TotInt in range(0, num_hdf):
            for mid in range(0, len(result[hid])):
                f.write("%e %d %d %d %d %e %e\n" %
                 (
                  result[hid][mid][4], result[hid][mid][0], result[hid][mid][1], result[hid][mid][2], result[hid][mid][3],
                  1/(result[hid][mid][4]*1.0), 1/(np.prod(np.array(result[hid][mid][0:4]))*1.0)
                 )
                )

    #fig = plt.figure(figsize=(12, 20))
    #xlist_n = []
    #ylist_n = []
    #for hid in range(0, num_hdf):
    #    print(1/tTotInt[hid]*1.0)
    #    xlist_n.append(1/tTotInt[hid]*1.0)
    #    ylist_n.append(1/(optid_x[hid][hid]*optid_y[hid][hid]*optid_z[hid][hid]*optid_w[hid][hid]*1.0))
    #print "xlist_n",xlist_n
    #for hid in range(0, num_hdf):
    #    xlist_m = []
    #    ylist_m = []
    #    for Indx_of_TotInt in range(hid, len(TotInt_ex[hid])):
    #        xlist_m.append(1/(TotInt_ex[hid][Indx_of_TotInt]*1.0))
    #        ylist_m.append(1/(optid_x[hid][Indx_of_TotInt]*optid_y[hid][Indx_of_TotInt]*optid_z[hid][Indx_of_TotInt]*optid_w[hid][Indx_of_TotInt]*1.0))
    #    if (hid+1 <= num_hdf/2):
    #        ax = fig.add_subplot(num_hdf//2, 2, 2*(hid+1)-1)
    #    else:
    #        ax = fig.add_subplot(num_hdf//2, 2, 2*(hid+1)-num_hdf)
    #    ax.scatter(xlist_n[hid:], ylist_n[hid:], marker='x', clip_on=False, s=50, label="each n")
    #    ax.scatter(xlist_m, ylist_m, marker='+', clip_on=False, s=72, label="prediction")
    #    ax.set_xlim(0, 0.00007)
    #    ax.set_ylim(0, 1.2)
    #    hour = hid + 1
    #    ax.text(0.25, 0.8, 'n at %dh'%hour,
    #    transform=ax.transAxes, ha="right")
#
#        if (hid+1 == 1):
##            ax.legend()

#        #if (hid+1 == 1 or hid+1 == num_hdf//2 + 1):
#            #ax.set_yticks([0, 0.02, 0.04, 0.06])
#        #else:
#            #ax.set_yticks([0, 0.02, 0.04])
#
#        ax.tick_params(labelbottom=False)
#        ax.tick_params(direction="in")
#        if (hid+1 == num_hdf//2 or hid+1 == num_hdf):
#            ax.tick_params(labelbottom=True)
#            ax.set_xlabel('1/m or 1/n')
#
#        #plt.gca().ticklabel_format(style="sci", scilimits=(0,0), axis="y")
#        plt.gca().ticklabel_format(style="sci", scilimits=(0, 0), axis="x")
#        if (hid == num_hdf//4 or hid == num_hdf//2 + num_hdf//4):
#            ax.set_ylabel('1/(wx*wy)')
#    plt.subplots_adjust(wspace=0.4, hspace=0.0)
#    #plt.savefig("result.txt.full.pdf")
#    plt.show()


runex()
