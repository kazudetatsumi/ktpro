#!/usr/bin/env python
# This script convert phonopy ouput (hdf5) to a simulated INS intensity
# distribution over the 4d space.
# The convolution function is similar to that in JPSJ2019.
# Kazuyoshi TATSUMI 2019.
# The size of tensor is adjusted to the experimental mask which is generated by Sample_D4Mat2.py
# important parameters:
# tcount        : total counts in the whole data domain
# dE            : energy bin width  (meV)
# dq            : q bin width       (rlu)
# lb_qx, ub_qx  : bounds for qx     (rlu)
import numpy as np
import h5py
import yaml
from matplotlib import pyplot as plt
import sys


def store_omega_in_goodarray(fn, mesh):
    f = h5py.File(fn, 'r')
    nmodes = f["frequency"].shape[1]      # f["frequency"]:[number of qpoints, number of modes], ordered as z indx increasing faster
    omega = np.reshape(f["frequency"][:],
                       [mesh[0], mesh[1], mesh[2], nmodes], order='C')  
    omega[omega < 0] = 0.0
    print("omega readed from qpoints.hdf5")
    return omega


def get_coord(n):
    if n % 2 == 1:
        x = np.arange(-n/2.0 + 1, n-n/2.0)/(n*1.0)
    if n % 2 == 0:
        x = np.arange(-n/2.0 - 1/2.0 + 1, n-n/2.0 + 1/2.0)/(n*1.0)
    print(x.shape[0])
    return x


def parse_rlat(my):
    with open(my) as f:
        data = yaml.load(f)
        rlat = data["primitive_cell"]["reciprocal_lattice"]
    rlat = np.array(rlat)
    return rlat


def get_ext_num(lb_q, ub_q, dq, norg):
    nqm = (-1*np.rint(lb_q/dq)) % (norg)
    nex = np.rint((ub_q - lb_q) / dq)
    return nqm.astype(int), nex.astype(int)


def extended_pdf(pdf, nqm, nex):
    norg = np.array(pdf.shape)
    expdf = np.zeros((nex[0], nex[1], nex[2], norg[3]))
    print(expdf.shape)
    for i in range(0, nex[0]):
        xidx = i % norg[0] - nqm[0]
        for j in range(0, nex[1]):
            yidx = j % norg[1] - nqm[1]
            for k in range(0, nex[2]):
                zidx = k % norg[2] - nqm[2]
                expdf[i, j, k, :] = pdf[xidx, yidx, zidx, :]
    return expdf


def conv_lore(omega, gamma, de, tcount):
    ene = np.arange(0.0, 40.0+de, de)
    nx = omega.shape[0]
    ny = omega.shape[1]
    nz = omega.shape[2]
    no = omega.shape[3]
    nene = ene.shape[0]
    pdf = np.zeros((nx, ny, nz, nene))
    for i in range(0, nx):
        for j in range(0, ny):
            for k in range(0, nz):
                for h in range(0, no):
                    pdf[i, j, k, :] += fun_lore(ene, gamma, omega[i, j, k, h])
    pdf = pdf / ((np.sum(pdf)*de))
    data4 = np.random.poisson(pdf*tcount)
    print("4D data is created.")
    return data4


def fun_lore(x, gamma, mean):
    dx = x[1] - x[0]
    l = (1 / 3.14) * 0.5 * gamma / ((x - mean)**2 + (0.5 * gamma)**2)
    l = l/(np.sum(l)*dx)
    return l


def set_plotparam(fig, axindx, data, hlb, hub, vub, fxdax1, fxdax2, fxdval1, fxdval2, axis):
    ax = fig.add_subplot(3, 4, axindx)
    ax.pcolor(np.transpose(data), vmax=np.max(data), cmap='jet')
    ax.set_ylabel('E')
    ax.axis('tight')
    ax.xaxis.set_label_coords(0.5, 1.145)
    ax.tick_params(direction="in", color="white", top=True, labeltop=True, labelbottom=False)
    ax.axvline(x=hlb, color='white', lw=0.5)
    ax.axvline(x=hub, color='white', lw=0.5)
    ax.axhline(y=vub, color='white', lw=0.5)
    ax.text(2, 38, fxdax1+'='+str(fxdval1)+','+fxdax2+'='+str(fxdval2), color='white')
    ax.set_xlabel(axis)


def plot_crosssection(xi, xe, yi, ye, zi, ze, ei, ee, data4):
    fig = plt.figure(figsize=(18, 9))
    fig.suptitle("crosssections of simulated 4D INS data", fontsize="x-large")
    axindx = 0
    for y in yi, ye:
        for z in zi, ze:
            axindx += 1
            set_plotparam(fig, axindx, data4[:, y, z, :], xi, xe, ee, 'qy', 'qx', y, z, 'qx')
    for x in xi, xe:
        for z in zi, ze:
            axindx += 1
            set_plotparam(fig, axindx, data4[x, :, z, :], yi, ye, ee, 'qx', 'qz', x, z, 'qy')
    for x in xi, xe:
        for y in yi, ye:
            axindx += 1
            set_plotparam(fig, axindx, data4[x, y, :, :], zi, ze, ee, 'qx', 'qy', x, y, 'qz')
    fig.subplots_adjust(top=0.90)


def save_h5py(data4, outfile):
    with h5py.File(outfile, 'w') as hf:
        hf.create_dataset('data4', data=data4)


def read_h5py(outfile):
    f = h5py.File(outfile)
    return f["data4"]


def get_condition(maskfile):
    f = h5py.File(maskfile)
    return f["condition"]


def save_eliminated_data_hdf5(elimifile, data, condition):
    with h5py.File(elimifile, 'w') as hf:
        hf.create_dataset('data4', data=data)
        hf.create_dataset('condition', data=condition)


def run():
    dq = 0.025
    dqx = dq
    dqy = dq
    dqz = dq
    lb_qx = -1.65
    ub_qx = 4.1
    lb_qy = -2.1
    ub_qy = 2.8
    lb_qz = -0.85
    ub_qz = 0.9
    xlin = np.arange(lb_qx, ub_qx, dqx)
    nx = xlin.shape[0]
    ylin = np.arange(lb_qy, ub_qy, dqy)
    ny = ylin.shape[0]
    zlin = np.arange(lb_qz, ub_qz, dqz)
    nz = zlin.shape[0]
    mesh = np.array([nx, ny, nz])

    PlanckConstant = 4.13566733e-15       # [eV s]
    THzTomev = PlanckConstant * 1e15      # [meV]
    gamma = 3.2                           # FWHM [meV]
    dE = 0.5                              # [meV]
    tcount = 20000000                     # [1]
    outfile = 'data3_'+str(tcount)+'.hdf5'
    qpointsfile = "/home/kazu/WORK/vasp-phonopy/cu/qpoints.hdf5"
    maskfile = "/home/kazu/desktop/200204/fine/out_hw_all.hdf5"
    omega = store_omega_in_goodarray(qpointsfile, mesh)*THzTomev  # [meV]
    data4 = conv_lore(omega, gamma, dE, tcount)
    save_h5py(data4, outfile)
    data4 = read_h5py(outfile)
    print(data4.shape)
    print(np.sum(data4))
    xi = 116
    xe = 172
    yi = 68
    ye = 140
    zi = 18
    ze = 51
    ei = 5*2
    ee = 35*2
    condition = get_condition(maskfile)
    data4 = np.array(data4)*np.array(condition)
    #print np.sum(data4)
    plot_crosssection(xi, xe, yi, ye, zi, ze, ei, ee, data4)
    elimifile = "eliminated_"+outfile
    #save_eliminated_data_hdf5(elimifile, data4[:, :, :, 5*2:], condition[:, :, :, 5*2:])
    #save_eliminated_data_hdf5(elimifile, data4[xi:xe, yi:ye, zi:ze, ei:ee], condition[xi:xe, yi:ye, zi:ze, ei:ee])




run()
plt.show()
